<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Affordances: Finding the Hidden Interfaces in Your Models</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/theme/black.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/monokai.css">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .reveal pre {
      width: 100%;
      margin: 0;
    }
    .reveal pre code {
      max-height: none;
      padding: 1rem;
    }
    .reveal h1, .reveal h2, .reveal h3 {
      text-transform: none;
    }
    .reveal ul, .reveal ol {
      display: block;
    }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title + Attribution -->
      <section data-background-color="#1e293b">
        <h1 class="text-6xl font-bold text-slate-100 mb-8">Affordances</h1>
        <h2 class="text-4xl text-slate-300 mb-12">Finding the Hidden Interfaces in Your Models</h2>
        <div class="text-xl text-slate-400 space-y-4">
          <p>Pattern credit: <a href="https://github.com/avit" class="text-blue-400">Andrew Vit (@avit)</a></p>
          <p class="mt-8">Chris Zempel</p>
        </div>

        <aside class="notes">
          <p><strong>Introduction (30 seconds):</strong></p>
          <ul>
            <li>Welcome everyone - this is a 5-minute lightning talk on a powerful Rails pattern</li>
            <li>You probably know concerns and service objects well</li>
            <li>Affordances fill the gap between them - revealing focused interfaces hidden in your models</li>
            <li>Pattern credit goes to Andrew Vit - this comes from real-world Rails development</li>
            <li>Let's dive in by looking at a familiar problem</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 2: What is an Affordance? -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-8">What is an Affordance?</h2>
        <div class="text-xl space-y-6">
          <div class="fragment">
            <p class="text-2xl text-blue-300 mb-3">Psychology/Design Definition:</p>
            <p class="text-lg text-slate-300 italic">"The actionable possibilities an object provides to an actor"</p>
            <div class="text-base text-slate-400 mt-3 ml-6 space-y-2">
              <p>‚Ä¢ A chair <span class="text-green-300">affords sitting</span></p>
              <p>‚Ä¢ A door handle <span class="text-green-300">affords pulling or pushing</span></p>
              <p>‚Ä¢ A button <span class="text-green-300">affords pressing</span></p>
            </div>
            <p class="text-sm text-slate-500 mt-4">‚Äî James J. Gibson (1966), popularized by Donald Norman (1988)</p>
          </div>
          <div class="fragment">
            <p class="text-2xl text-yellow-300 mb-3">In Code:</p>
            <p class="text-lg text-slate-300">"The actionable possibilities your model provides"</p>
            <div class="bg-slate-800 p-4 rounded mt-3 text-base">
              <p class="text-slate-400">An Article doesn't just store data‚Äîit <span class="text-green-300">affords</span>:</p>
              <p class="mt-2 ml-4">‚Ä¢ <code>article.publication</code> ‚Äî publication operations</p>
              <p class="ml-4">‚Ä¢ <code>article.revision</code> ‚Äî revision management</p>
              <p class="ml-4">‚Ä¢ <code>article.workflow</code> ‚Äî workflow coordination</p>
            </div>
          </div>
          <div class="fragment">
            <p class="text-xl text-slate-200 mt-6">üí° We're not adding behavior‚Äîwe're <em>revealing</em> what the object already affords</p>
          </div>
        </div>

        <aside class="notes">
          <p><strong>What is an Affordance? (45 seconds):</strong></p>
          <ul>
            <li>Fragment 1: The term comes from psychology and design - coined by James Gibson in 1966, popularized by Donald Norman in 1988</li>
            <li>An affordance is the actionable possibilities an object provides - what you can DO with it</li>
            <li>A chair affords sitting, a door handle affords pulling, a button affords pressing</li>
            <li>Fragment 2: In code, same concept - what actionable possibilities does your model provide?</li>
            <li>An Article doesn't just hold data - it affords publication operations, revision management, workflow coordination</li>
            <li>Fragment 3: Key insight - we're not adding new behavior, we're REVEALING what was always there</li>
            <li>The publication aspect already existed in those publication_ methods - we're just making it explicit and discoverable</li>
            <li>Transition: Let's look at a familiar problem that shows why we need this pattern</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 3: The Mess - Fat Model -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">The Familiar Problem</h2>
        <pre><code class="language-ruby text-base" data-trim data-line-numbers="1-6|8-12|14-17|19">
class Article < ApplicationRecord
  has_many :revisions
  has_many :publication_events
  has_many :workflow_assignments

  # üö© Revision management (repetitive prefix)
  def revision_create_from_current!
  def revision_restore!(revision)
  def revision_compare(revision_a, revision_b)
  def revision_list_changes
  def revision_prune_old!

  # üö© Workflow coordination (multi-association)
  def assign_approver!(user, role:)
    workflow_assignments.create!(...)
    publication_events.create!(...)
  end

  # ... 50 more methods ...
end
        </code></pre>
        <p class="text-xl text-yellow-300 mt-6 fragment">ü§î Are those 50 methods possibly related in other ways? Who knows!</p>

        <aside class="notes">
          <p><strong>The Fat Model Problem (50 seconds):</strong></p>
          <ul>
            <li>This is a standard Rails model - everything goes in Article</li>
            <li>First highlight: Notice all these methods starting with "revision_"? That's a code smell - the repetitive prefix tells us something</li>
            <li>Second highlight: Workflow coordination touches multiple associations at once - workflow_assignments AND publication_events</li>
            <li>Third highlight: 67 methods total in this model - it's getting hard to navigate</li>
            <li>Fourth highlight (fragment): And here's the kicker - those 50 other methods are probably related in ways we can't see! Some might cluster around concepts we haven't named yet</li>
            <li>The relationships between these methods are buried - you can't see at a glance which methods work together</li>
            <li>Transition: Let's look at why this hurts</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 3: Pain Points Diagram -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">What's the Pain?</h2>
        <div class="text-xl text-left space-y-6">
          <div class="fragment">
            <p class="text-2xl text-red-300 mb-2">‚ùå Hard to discover related methods</p>
            <p class="text-lg text-slate-400 ml-8">Which methods work together? Can't tell at a glance</p>
          </div>
          <div class="fragment">
            <p class="text-2xl text-red-300 mb-2">‚ùå Can't pass around focused capability</p>
            <p class="text-lg text-slate-400 ml-8">Want to give a service just publication behavior? You have to pass the whole Article</p>
          </div>
          <div class="fragment">
            <p class="text-2xl text-red-300 mb-2">‚ùå Mixing concerns</p>
            <p class="text-lg text-slate-400 ml-8">Core Article logic mixed with lifecycle, workflow, versioning...</p>
          </div>
          <div class="fragment">
            <p class="text-2xl text-red-300 mb-2">‚ùå Testing complexity</p>
            <p class="text-lg text-slate-400 ml-8">Every test requires full Article setup even when you only care about one aspect</p>
          </div>
        </div>

        <aside class="notes">
          <p><strong>Pain Points (45 seconds):</strong></p>
          <ul>
            <li>Fragment 1: Discoverability - you can't see which methods are related without reading through all 67</li>
            <li>Fragment 2: Composability - you can't pass around just "publication" behavior, you have to pass the whole Article object</li>
            <li>Fragment 3: Mixing concerns - hard to see dependencies between methods when ALL attributes and methods are in scope. Core Article logic (title, body) mixed with publication lifecycle, workflow coordination, versioning - everything can touch everything</li>
            <li>Fragment 4: Testing gets harder because you need the full Article even when you're just testing publication logic</li>
            <li>Pause after all fragments: So how do we fix this?</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 4: Pattern Recognition -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-8">Spotting Affordances</h2>
        <div class="text-xl space-y-8">
          <div class="fragment">
            <p class="text-2xl text-yellow-300 mb-3">üîç Trigger #1: Repetitive Prefixes</p>
            <div class="bg-slate-800 p-4 rounded text-base">
              <code>revision_create_from_current!, revision_restore!, revision_compare!</code>
              <br/>
              <span class="text-green-300">‚Üí Extract: <code>article.revision</code></span>
            </div>
          </div>
          <div class="fragment">
            <p class="text-2xl text-yellow-300 mb-3">üîç Trigger #2: Multi-Association Coordination</p>
            <div class="bg-slate-800 p-4 rounded text-base">
              <code>assign_approver!</code> <span class="text-slate-500">(touches 2+ associations)</span>
              <br/>
              <span class="text-green-300">‚Üí Extract: <code>article.workflow</code></span>
            </div>
          </div>
          <div class="fragment">
            <p class="text-2xl text-yellow-300 mb-3">üîç Trigger #3: Unclear Relationships</p>
            <div class="bg-slate-800 p-4 rounded text-base">
              <code>draft?, publish!, archive!, scheduled?</code>
              <br/>
              <span class="text-green-300">‚Üí Extract: <code>article.publication</code></span>
            </div>
          </div>
        </div>
        <p class="text-xl text-slate-300 mt-8 fragment">üí° Sometimes the prefix IS the noun you're looking for</p>

        <aside class="notes">
          <p><strong>Pattern Recognition (60 seconds):</strong></p>
          <ul>
            <li>Fragment 1: First trigger is repetitive prefixes - "revision_" appears on 5+ methods. The prefix is unnatural - you wouldn't normally prefix everything with "revision_"</li>
            <li>Fragment 2: Second trigger is multi-association coordination - when one method like assign_approver! touches multiple associations (workflow_assignments AND publication_events), that's a coordinating affordance</li>
            <li>Fragment 3: Third trigger is unclear relationships - look at draft?, publish!, archive!, scheduled? Without a prefix or context, you can't tell these are related to publication! That hidden relationship is the affordance waiting to be revealed</li>
            <li>Final fragment: Key insight - SOMETIMES the prefix IS the noun (revision_ ‚Üí article.revision). Other times, the missing context IS the noun (draft/publish/archive ‚Üí article.publication)</li>
            <li>Emphasize: We're revealing what Article already affords you - these aspects were always there, just hidden</li>
            <li>Transition: Let's see what this looks like in code</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 5a: The Goal - Usage Pattern -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">The Goal</h2>
        <div class="grid grid-cols-2 gap-8">
          <div>
            <h3 class="text-2xl text-red-300 mb-4">‚ùå Before</h3>
            <pre><code class="language-ruby text-base" data-trim>
article.revision_create_from_current!
article.revision_restore!(rev)
article.revision_compare(a, b)
article.revision_list_changes
            </code></pre>
            <p class="text-lg text-slate-400 mt-4">Repetitive prefix on every call</p>
          </div>
          <div class="fragment">
            <h3 class="text-2xl text-green-300 mb-4">‚úÖ After</h3>
            <pre><code class="language-ruby text-base" data-trim>
article.revision.create_from_current!
article.revision.restore!(rev)
article.revision.compare(a, b)
article.revision.list_changes
            </code></pre>
            <p class="text-lg text-green-300 mt-4">Clean interface grouped by concept</p>
          </div>
        </div>
        <div class="mt-8 fragment">
          <p class="text-2xl text-slate-200">üí° Focus on: <code class="text-blue-300">revision.create_from_current!</code></p>
          <p class="text-lg text-slate-400 mt-2">Prefix becomes the noun - clean, discoverable</p>
        </div>

        <aside class="notes">
          <p><strong>The Goal (30 seconds):</strong></p>
          <ul>
            <li>Left side: Before - notice how "revision_" repeats on every single call? That's visual noise and a code smell</li>
            <li>Fragment 1: After - now look at the right side. We extract the prefix as the affordance</li>
            <li>What stands out? revision.create_from_current!, revision.restore!, revision.compare - all revision operations together</li>
            <li>Fragment 2: The repetitive prefix becomes the noun - revision.create_from_current! is clean and discoverable</li>
            <li>This is what we're aiming for - turn that prefix smell into a focused interface</li>
            <li>Next slide shows HOW to implement this transformation</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 5b: The Transformation - Implementation -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">How to Extract It</h2>
        <div class="grid grid-cols-2 gap-8">
          <div>
            <h3 class="text-2xl text-red-300 mb-4">‚ùå Before</h3>
            <pre><code class="language-ruby text-base" data-trim>
class Article
  def revision_create_from_current!
    revisions.create!(
      content: body,
      metadata: attributes.slice(...)
    )
  end
end

article.revision_create_from_current!
            </code></pre>
          </div>
          <div class="fragment">
            <h3 class="text-2xl text-green-300 mb-4">‚úÖ After</h3>
            <pre><code class="language-ruby text-base" data-trim>
class Article
  def revision
    Article::Revision.new(self)
  end
end

class Article::Revision # PORO
  def initialize(article)
    @article = article
  end

  def create_from_current!
    @article.revisions.create!(...)
  end
end

article.revision.create_from_current!
            </code></pre>
          </div>
        </div>

        <aside class="notes">
          <p><strong>How to Extract (45 seconds):</strong></p>
          <ul>
            <li>Left side: Before - revision_create_from_current! is a method directly on Article with that ugly prefix</li>
            <li>Right side fragment: After - we extract Article::Revision as a PORO (Plain Old Ruby Object)</li>
            <li>Key implementation details: Article provides "revision" method that returns new instance</li>
            <li>Note: No memoization shown here to keep it simple - you can add @revision ||= if needed</li>
            <li>Article::Revision is namespaced under Article - keeps things organized</li>
            <li>It's NOT an ActiveRecord model - just a wrapper that takes article as only dependency</li>
            <li>Usage: article.revision.create_from_current! - the prefix becomes the noun, method becomes clean verb</li>
            <li>This pattern works for any repetitive prefix you find</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 6: What Makes an Affordance -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-8">What Makes an Affordance?</h2>
        <div class="text-xl space-y-8">
          <div class="fragment">
            <div class="flex items-start space-x-4">
              <span class="text-4xl">1Ô∏è‚É£</span>
              <div>
                <p class="text-2xl font-semibold text-blue-300 mb-3">Only required dependency is the parent object</p>
                <pre><code class="language-ruby text-base" data-trim>
Article::Publication.new(article)  # ‚úÖ Only parent
article.publication.publish!(at: Time.current)  # params go to methods
                </code></pre>
                <p class="text-base text-slate-400 mt-2">Runtime parameters belong in method calls, not the initializer</p>
              </div>
            </div>
          </div>
          <div class="fragment">
            <div class="flex items-start space-x-4">
              <span class="text-4xl">2Ô∏è‚É£</span>
              <div>
                <p class="text-2xl font-semibold text-blue-300 mb-3">Provides a subset of functionality</p>
                <p class="text-base text-slate-400">Unlike a decorator (which wraps ALL methods), an affordance exposes only the methods relevant to its concept</p>
                <div class="grid grid-cols-2 gap-4 mt-3 text-sm">
                  <div>
                    <p class="text-green-300 mb-1">‚úÖ Affordance</p>
                    <code>article.publication</code><br/>
                    <span class="text-slate-400">‚Üí Just publication ops</span>
                  </div>
                  <div>
                    <p class="text-red-300 mb-1">‚ùå Decorator</p>
                    <code>PublishedArticle.new(article)</code><br/>
                    <span class="text-slate-400">‚Üí Wraps all Article methods</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <aside class="notes">
          <p><strong>What Makes an Affordance (45 seconds):</strong></p>
          <ul>
            <li>Fragment 1: First defining property - parent is the ONLY required dependency</li>
            <li>Article::Publication.new takes only the article - nothing else in the initializer</li>
            <li>Runtime parameters like "at" or "user" go to method calls, not initialization</li>
            <li>Fragment 2: Second property - subset of functionality, not a wrapper</li>
            <li>This is KEY distinction from decorator pattern - decorator wraps ALL methods</li>
            <li>Affordance exposes ONLY the methods related to its specific concept</li>
            <li>article.publication gives you just publication operations, not all Article methods</li>
            <li>These two properties together define what an affordance is</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 7: Parameterization Signals Wrong Level -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">Finding the Right Level</h2>
        <p class="text-xl text-yellow-300 mb-6">üö© If you always need the same parameter, you're at the wrong level</p>
        <div class="grid grid-cols-2 gap-8">
          <div>
            <h3 class="text-2xl text-red-300 mb-4">‚ùå Wrong Level</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Store has_many :products
# Product has_many :variants

class Store
  def inventory
    Store::Inventory.new(self)
  end
end

class Store::Inventory
  def stock_level(product)
    # Always need product!
  end

  def reorder_point(product)
    # Always need product!
  end
end

# Usage - always passing product
store.inventory.stock_level(product)
store.inventory.reorder_point(product)
            </code></pre>
          </div>
          <div class="fragment">
            <h3 class="text-2xl text-green-300 mb-4">‚úÖ Right Level</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Move affordance down the hierarchy
# to where parameter is the parent

class Product
  def inventory
    Product::Inventory.new(self)
  end
end

class Product::Inventory
  def stock_level
    # No parameter needed!
    # Aggregates across variants
  end

  def reorder_point
  end
end

# Usage - no parameter needed
product.inventory.stock_level
product.inventory.reorder_point
            </code></pre>
          </div>
        </div>
        <div class="mt-6 fragment">
          <p class="text-xl text-slate-200">üí° Bonus: Reuse existing navigation</p>
          <pre class="mt-2"><code class="language-ruby text-base" data-trim>
store.products.find_by(sku: 'ABC-123').inventory.stock_level
          </code></pre>
        </div>

        <aside class="notes">
          <p><strong>Finding the Right Level (45 seconds):</strong></p>
          <ul>
            <li>Here's a key insight - parameterization gives you feedback about hierarchy placement</li>
            <li>Left side: Store has many Products, Product has many Variants</li>
            <li>If you put inventory affordance on Store, every method needs product parameter</li>
            <li>stock_level(product), reorder_point(product) - you ALWAYS pass the same thing</li>
            <li>Fragment 1: This is feedback - move down the hierarchy!</li>
            <li>Put the affordance on Product instead - now product IS the parent, no parameter needed</li>
            <li>product.inventory.stock_level - clean, no parameters</li>
            <li>Fragment 2: Bonus benefit - you can reuse your existing navigation API</li>
            <li>store.products.find_by chains naturally into .inventory.stock_level</li>
            <li>Rule: If you always need parameter X, X should probably be the parent of your affordance</li>
            <li>Transition: Now let's look at an anti-pattern</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 8: Anti-Pattern - Single-Method Services -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">‚ö†Ô∏è Anti-Pattern Alert</h2>
        <div class="grid grid-cols-2 gap-8">
          <div>
            <h3 class="text-2xl text-red-300 mb-4">‚ùå Single-Method Service Objects</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Ends up with lots of
# single-method boilerplate files

ThingDoer.new.do_thing

ArticlePublisher.new.publish
ArticleArchiver.new.archive
ArticleScheduler.new.schedule
ArticleUnpublisher.new.unpublish

# Each in its own file
# Hard to discover related operations
            </code></pre>
          </div>
          <div class="fragment">
            <h3 class="text-2xl text-green-300 mb-4">‚úÖ Affordance: Group Related Ops</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Related methods grouped by concept
# All discoverable in one place

article.publication.publish!
article.publication.archive!
article.publication.schedule!(at)
article.publication.unpublish!

# Plus queries:
article.publication.draft?
article.publication.scheduled?
            </code></pre>
          </div>
        </div>
        <div class="mt-6 space-y-3">
          <p class="text-xl text-slate-300 fragment">üí° If your service objects cluster around one concept, consider an affordance</p>
          <p class="text-lg text-yellow-300 fragment">üö© Smell: Repeated code across service objects (validation, required query methods)</p>
        </div>

        <aside class="notes">
          <p><strong>Anti-Pattern Warning (35 seconds):</strong></p>
          <ul>
            <li>Left side: Common anti-pattern - single-method service objects</li>
            <li>You end up with ThingDoer.do_thing, ArticlePublisher.publish, ArticleArchiver.archive, etc.</li>
            <li>Each lives in its own file, hard to discover what operations are available</li>
            <li>Fragment 1: Instead, group these related operations into an affordance</li>
            <li>All publication operations live together under article.publication</li>
            <li>Bonus: You can mix commands (publish!, archive!) with queries (draft?, scheduled?)</li>
            <li>Fragment 2: Key insight - if your service objects cluster around one concept, that's an affordance</li>
            <li>Fragment 3: Another smell - those service objects probably have repeated code! Validation, required query methods, shared setup. That duplication goes away when you extract to an affordance</li>
            <li>Transition: So when do you use each pattern?</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 8: Decision Questions -->
      <section data-background-color="#1e293b">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">How to Decide?</h2>
        <p class="text-2xl text-yellow-300 mb-6">‚≠ê North Star: Call-Site Clarity</p>
        <div class="text-lg space-y-4 text-left">
          <div class="fragment">
            <p class="text-xl text-blue-300 font-semibold">1. "Would someone understand from the call site?"</p>
            <div class="text-base ml-6 mt-2 space-y-1">
              <p class="text-green-300"><code>article.publication.publish!</code> ‚Üí Self-evident ‚úÖ</p>
              <p class="text-red-300"><code>article.renew!</code> ‚Üí Renew what? Context missing üö©</p>
              <p class="text-red-300"><code>article.assign_editor!(user)</code> ‚Üí What else can I do? No directory üö©</p>
            </div>
            <p class="text-slate-400 ml-6 mt-2 italic">Affordance provides context AND discoverability</p>
          </div>
          <div class="fragment">
            <p class="text-xl text-blue-300 font-semibold">2. "Do I call this, or does Rails call it?"</p>
            <p class="text-slate-400 ml-6">Explicit calls ‚Üí Affordance ‚Ä¢ Implicit (callbacks) ‚Üí Concern</p>
          </div>
          <div class="fragment">
            <p class="text-xl text-blue-300 font-semibold">3. "Can I pass this piece around?"</p>
            <p class="text-slate-400 ml-6">Yes ‚Üí Affordance ‚Ä¢ No ‚Üí Probably concern</p>
          </div>
          <div class="fragment">
            <p class="text-xl text-blue-300 font-semibold">4. "Do 3+ method names cluster around a noun?"</p>
            <p class="text-slate-400 ml-6">Yes ‚Üí Extract that noun as affordance (prefix = noun)</p>
          </div>
          <div class="fragment">
            <p class="text-xl text-blue-300 font-semibold">5. "Need infrastructure AND operations?"</p>
            <p class="text-slate-400 ml-6">Yes ‚Üí Concern + Affordance ‚Ä¢ Just callbacks ‚Üí Concern only</p>
            <p class="text-slate-400 ml-6">Just operations ‚Üí Affordance only</p>
          </div>
        </div>

        <aside class="notes">
          <p><strong>Decision Questions (60 seconds):</strong></p>
          <ul>
            <li>Call-Site Clarity is your North Star - always start here</li>
            <li>Fragment 1: First question - would someone understand what this does just from reading the call site? This is THE most important question</li>
            <li>article.publication.publish! is self-evident - you know exactly what it does</li>
            <li>article.renew! - renew what? Subscription? License? Context is missing</li>
            <li>article.assign_editor!(user) - this works, but how do I discover what ELSE I can do? Is there unassign_editor? What other workflow methods exist? No directory to browse</li>
            <li>Affordances solve BOTH problems - they provide context (article.subscription.renew!) AND discoverability (article.workflow has all the workflow methods in one place)</li>
            <li>Fragment 2: Do you explicitly call this method, or does Rails call it automatically? Explicit calls suggest affordance, callbacks/validations suggest concern</li>
            <li>Fragment 3: Can you pass this piece to another method meaningfully? notify_subscribers(article.publication) makes sense. Concerns can't be passed around</li>
            <li>Fragment 4: Do 3+ method names cluster around a noun? That noun is your affordance waiting to be extracted</li>
            <li>Fragment 5: Need both infrastructure AND explicit operations? Concern provides has_many and callbacks, affordance provides the API. Or just one or the other</li>
            <li>These questions give you a systematic framework for making the choice</li>
            <li>Transition: Now let's see the patterns side by side</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 9: Decision Framework -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">When to Use What?</h2>
        <table class="text-base w-full">
          <thead>
            <tr class="text-left">
              <th class="text-xl text-slate-300 pb-4">Pattern</th>
              <th class="text-xl text-slate-300 pb-4">Use When</th>
              <th class="text-xl text-slate-300 pb-4">Example</th>
            </tr>
          </thead>
          <tbody class="text-slate-200">
            <tr class="fragment">
              <td class="text-lg font-semibold text-blue-300 pr-4 pb-3">Concern</td>
              <td class="pr-4 pb-3">Implicit behavior only<br/><span class="text-sm text-slate-400">(callbacks, validations)</span></td>
              <td class="pb-3"><code>Searchable (after_save)</code></td>
            </tr>
            <tr class="fragment">
              <td class="text-lg font-semibold text-purple-300 pr-4 pb-3">Service</td>
              <td class="pr-4 pb-3">Single complex workflow</td>
              <td class="pb-3"><code>ArticlePublisher.publish</code></td>
            </tr>
            <tr class="fragment">
              <td class="text-lg font-semibold text-yellow-300 pr-4 pb-3">Assoc Ext</td>
              <td class="pr-4 pb-3">Extending one association</td>
              <td class="pb-3"><code>article.revisions.recent</code></td>
            </tr>
            <tr class="fragment">
              <td class="text-lg font-semibold text-green-300 pr-4 pb-3">Affordance</td>
              <td class="pr-4 pb-3">Explicit behavior grouped by concept<br/><span class="text-sm text-slate-400">Parent is ONLY dependency</span></td>
              <td class="pb-3"><code>article.publication.publish!</code></td>
            </tr>
            <tr class="fragment">
              <td class="text-lg font-semibold text-cyan-300 pr-4 pb-3">Concern + Affordance</td>
              <td class="pr-4 pb-3">Infrastructure AND operations<br/><span class="text-sm text-slate-400">Concern sets up, affordance provides API</span></td>
              <td class="pb-3"><code>UsageCredits (has_many + .usage_credits)</code></td>
            </tr>
          </tbody>
        </table>
        <div class="mt-8 fragment">
          <p class="text-2xl text-slate-200">üí° Concerns: implicit behavior, Affordances: explicit behavior</p>
          <p class="text-xl text-slate-400 mt-3">When you see repetitive prefixes ‚Üí think affordance</p>
        </div>

        <aside class="notes">
          <p><strong>Decision Framework (60 seconds):</strong></p>
          <ul>
            <li>You have FIVE tools in your toolkit - let's see when to use each</li>
            <li>Fragment 1: Concerns for implicit behavior ONLY - Searchable with after_save callbacks that run automatically</li>
            <li>Fragment 2: Service objects for single complex workflows - you call them once for a complex operation</li>
            <li>Fragment 3: Association extensions for extending a single association's collection methods</li>
            <li>Fragment 4: Affordances organize explicit behavior - multiple operations you call directly, grouped by concept. Parent is the ONLY dependency</li>
            <li>Fragment 5: NEW - Concern + Affordance combined! Concern provides infrastructure (has_many, callbacks), affordance provides the API</li>
            <li>Final fragment: Key distinction - concerns for implicit behavior (callbacks only), affordances for explicit behavior (methods you call)</li>
            <li>When you see repetitive prefixes like publication_, that's your signal to extract an affordance</li>
            <li>Transition: Let's wrap up</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 10: Closing Summary -->
      <section data-background-color="#1e293b">
        <h2 class="text-5xl font-bold text-slate-100 mb-8">Affordances in Practice</h2>
        <div class="text-xl space-y-6 text-left">
          <div class="flex items-start space-x-4">
            <span class="text-3xl">üîç</span>
            <div>
              <p class="font-semibold text-slate-200">Spot:</p>
              <p class="text-slate-400">Repetitive prefixes, multi-association coordination</p>
            </div>
          </div>
          <div class="flex items-start space-x-4">
            <span class="text-3xl">üéØ</span>
            <div>
              <p class="font-semibold text-slate-200">Extract:</p>
              <p class="text-slate-400">PORO wrapper with parent as ONLY dependency</p>
            </div>
          </div>
          <div class="flex items-start space-x-4">
            <span class="text-3xl">‚ö†Ô∏è</span>
            <div>
              <p class="font-semibold text-slate-200">Rule:</p>
              <p class="text-slate-400">Need other args? Extract more granular affordance</p>
            </div>
          </div>
          <div class="flex items-start space-x-4">
            <span class="text-3xl">üß∞</span>
            <div>
              <p class="font-semibold text-slate-200">Choose:</p>
              <p class="text-slate-400">Right tool for the job (concerns/services/affordances)</p>
            </div>
          </div>
        </div>
        <div class="mt-12 text-lg text-slate-400">
          <p>Pattern credit: <a href="https://github.com/avit" class="text-blue-400">Andrew Vit (@avit)</a></p>
          <p class="mt-6 text-2xl text-slate-200">Questions?</p>
        </div>

        <aside class="notes">
          <p><strong>Closing Summary (10 seconds):</strong></p>
          <ul>
            <li>Quick recap: Spot affordances by looking for repetitive prefixes or multi-association coordination</li>
            <li>Extract them as POROs with parent as the only dependency</li>
            <li>Remember the rule - if you need other args, extract a more granular affordance</li>
            <li>Use the right tool - concerns for traits, affordances for aspects</li>
            <li>Credit to Andrew Vit for this pattern</li>
            <li>Open for questions</li>
          </ul>
          <p><strong>Anticipated Questions:</strong></p>
          <ul>
            <li>Q: "When would I use this instead of a concern?" A: Concerns are for implicit behavior ONLY - callbacks and validations that Rails calls automatically (like Searchable with after_save). Affordances organize explicit behavior you call directly. Sometimes you need both - concern provides infrastructure, affordance provides API.</li>
            <li>Q: "Isn't this just a service object?" A: Services are single-purpose workflows. Affordances are reusable interfaces with multiple related operations. If you have multiple single-method services around one concept (ArticlePublisher, ArticleArchiver), that's an affordance waiting to be extracted.</li>
            <li>Q: "What about performance?" A: Memoization means one object per parent instance - negligible overhead.</li>
            <li>Q: "Can I use concerns AND affordances together?" A: Absolutely! Concern sets up has_many associations and callbacks, then provides an affordance method for explicit operations. UsageCredits is a great example.</li>
          </ul>
        </aside>
      </section>

      <!-- Slide 11: Bonus - Unified API Surfaces -->
      <section data-background-color="#0f172a">
        <h2 class="text-4xl font-bold text-slate-100 mb-6">üéÅ Bonus: Unified API Surfaces</h2>
        <p class="text-2xl text-slate-300 mb-8">Same concept, different levels, same interface</p>

        <div class="grid grid-cols-2 gap-8">
          <div>
            <h3 class="text-xl text-blue-300 mb-4">Part Level</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Transaction-level ledger
transaction.ledger.balance
transaction.ledger.entries
transaction.ledger.reconcile!

# Different implementation:
# Queries own entries directly
            </code></pre>
          </div>
          <div class="fragment">
            <h3 class="text-xl text-green-300 mb-4">Whole Level</h3>
            <pre><code class="language-ruby text-base" data-trim>
# Account-level ledger
account.ledger.balance
account.ledger.entries
account.ledger.reconcile!

# Different implementation:
# Aggregates across transactions
            </code></pre>
          </div>
        </div>

        <div class="mt-8 fragment">
          <p class="text-xl text-slate-300 mb-4">üí° Same affordance interface, different implementations</p>
          <div class="bg-slate-800 p-4 rounded text-base">
            <code class="text-slate-200">
              # Polymorphic usage - works at any level<br/>
              def show_ledger_summary(record)<br/>
              &nbsp;&nbsp;record.ledger.balance<br/>
              &nbsp;&nbsp;record.ledger.entries.last(10)<br/>
              end<br/>
              <br/>
              show_ledger_summary(transaction) # Works!<br/>
              show_ledger_summary(account)     # Works!
            </code>
          </div>
        </div>

        <aside class="notes">
          <p><strong>Bonus Pattern - Unified API Surfaces (30 seconds):</strong></p>
          <ul>
            <li>Here's a really cool advanced pattern - providing the same affordance API at different conceptual levels</li>
            <li>Left side: Transaction has a ledger affordance - queries its own entries directly</li>
            <li>Fragment 1: Account also has a ledger affordance - but aggregates across all its transactions</li>
            <li>Same interface (balance, entries, reconcile!), completely different implementations</li>
            <li>Fragment 2: The power - you can write polymorphic code that works at any level</li>
            <li>This is particularly useful for part/whole relationships - transactions roll up into accounts, line items into invoices, etc.</li>
            <li>Different traversal and aggregation logic, but unified concept and API surface</li>
            <li>This makes your code incredibly flexible and composable</li>
          </ul>
        </aside>
      </section>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/dist/reveal.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/notes/notes.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/markdown/markdown.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5.0.4/plugin/highlight/highlight.js"></script>
  <script>
    Reveal.initialize({
      slideNumber: 'c/t',
      hash: true,
      width: '100%',
      height: '100%',
      transition: 'slide',
      controls: true,
      progress: true,
      keyboard: true,
      overview: true,
      plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
    });
  </script>
</body>
</html>
